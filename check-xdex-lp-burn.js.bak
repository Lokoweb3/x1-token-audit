#!/usr/bin/env node
/**
 * check-xdex-lp-burn.js
 * ===========================================
 * XDEX LP Burn Checker v2.5 â€” Restructured Output
 * ===========================================
 *
 * Usage:
 *   node check-xdex-lp-burn.js <TOKEN_MINT_ADDRESS>
 *
 * Requirements:
 *   npm install @solana/web3.js@1
 */

const { Connection, PublicKey } = require("@solana/web3.js");
const https = require("https");

const DEFAULT_RPC = process.env.X1_RPC_URL || "https://rpc.mainnet.x1.xyz";
const XDEX_API = "https://api.xdex.xyz/api";

const BURN_ADDRESSES = [
  "1nc1nerator11111111111111111111111111111111",
  "11111111111111111111111111111111",
  "1111111111111111111111111111111111111111111",
];

// â”€â”€â”€ Visual Helpers â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

function shortAddr(addr, len = 6) {
  if (!addr) return "N/A";
  return addr.length > len * 2 ? `${addr.slice(0, len)}...${addr.slice(-len)}` : addr;
}

function formatNumber(n) {
  if (typeof n === "string") n = parseFloat(n);
  if (isNaN(n)) return "N/A";
  if (n >= 1e12) return (n / 1e12).toFixed(2) + "T";
  if (n >= 1e9) return (n / 1e12).toFixed(2) + "B";
  if (n >= 1e6) return (n / 1e6).toFixed(2) + "M";
  if (n >= 1e3) return (n / 1e3).toFixed(2) + "K";
  return n.toFixed(2);
}

function progressBar(percent, width = 20) {
  const filled = Math.round((percent / 100) * width);
  const empty = width - filled;
  const bar = "â–ˆ".repeat(filled) + "â–‘".repeat(empty);
  return `[${bar}] ${percent.toFixed(1)}%`;
}

function riskGauge(score) {
  const segments = 10;
  const filled = Math.round((score / 100) * segments);
  let gauge = "";
  for (let i = 0; i < segments; i++) {
    if (i < filled) {
      if (score >= 50) gauge += "ðŸ”´";
      else if (score >= 25) gauge += "ðŸŸ¡";
      else gauge += "ðŸŸ¢";
    } else {
      gauge += "âšª";
    }
  }
  return gauge;
}

function timestamp() {
  return new Date().toISOString().replace("T", " ").split(".")[0] + " UTC";
}

// â”€â”€â”€ API / Chain Helpers â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

async function fetchJSON(url) {
  return new Promise((resolve, reject) => {
    https.get(url, (res) => {
      let data = "";
      res.on("data", chunk => data += chunk);
      res.on("end", () => {
        try {
          resolve(JSON.parse(data));
        } catch (e) {
          reject(new Error("Invalid JSON response"));
        }
      });
    }).on("error", reject);
  });
}

async function getTokenMetadata(tokenAddress, pools) {
  // Try XDEX pools for price calculation
  if (pools && pools.length > 0) {
    // Find a pool with valid price data
    for (const pool of pools) {
      try {
        // Determine which token is AGI and get its price
        let tokenPrice = null;
        let tokenSymbol = "";
        
        if (pool.token1_address === tokenAddress && pool.token1_price) {
          tokenPrice = pool.token1_price;
          tokenSymbol = pool.token1_symbol;
        } else if (pool.token2_address === tokenAddress && pool.token2_price) {
          tokenPrice = pool.token2_price;
          tokenSymbol = pool.token2_symbol;
        }
        
        if (tokenPrice && tokenPrice > 0) {
          // Get base token price (WXNT = XNT on X1)
          const baseTokenPrice = pool.token1_symbol === "WXNT" ? pool.token1_price : 1;
          const finalPrice = tokenPrice * baseTokenPrice;
          
          // Calculate market cap (use supply from mint data)
          const supply = (pool.total_supply || 500000000);
          const marketCap = supply * finalPrice;
          
          return {
            price: `$${finalPrice.toFixed(8)}`,
            marketCap: `$${marketCap >= 1e6 ? (marketCap/1e6).toFixed(2) + 'M' : marketCap >= 1e3 ? (marketCap/1e3).toFixed(2) + 'K' : marketCap.toFixed(2)}`,
            liquidity: `$${formatNumber(pool.tvl * baseTokenPrice)}`,
            volume24h: `$${formatNumber(pool.token2_volume_usd_24h || pool.token1_volume_usd_24h || 0)}`,
          };
        }
      } catch {
        // Try next pool
      }
    }
  }
  
  return {
    price: "$N/A",
    marketCap: "$N/A",
    liquidity: "$N/A",
    volume24h: "$N/A",
  };
}

async function checkTokenAuthorities(connection, mintPubkey) {
  const result = {
    mintAuthority: null,
    mintAuthorityRevoked: false,
    freezeAuthority: null,
    freezeAuthorityRevoked: false,
    supply: 0,
    decimals: 0,
  };

  try {
    const accountInfo = await connection.getAccountInfo(mintPubkey);
    if (!accountInfo) return result;

    const data = accountInfo.data;
    if (data.length >= 82) {
      const mintAuthOption = data.readUInt32LE(0);
      if (mintAuthOption === 1) {
        result.mintAuthority = new PublicKey(data.slice(4, 36)).toBase58();
      } else {
        result.mintAuthorityRevoked = true;
      }

      const supplyLow = BigInt(data.readUInt32LE(36));
      const supplyHigh = BigInt(data.readUInt32LE(40));
      result.supply = Number((supplyHigh << BigInt(32)) | supplyLow);
      result.decimals = data.readUInt8(44);

      const freezeAuthOption = data.readUInt32LE(46);
      if (freezeAuthOption === 1) {
        result.freezeAuthority = new PublicKey(data.slice(50, 82)).toBase58();
      } else {
        result.freezeAuthorityRevoked = true;
      }
    }
  } catch (err) {
    console.error(`Error reading mint: ${err.message}`);
  }

  return result;
}

async function getTokenHolders(connection, mintAddress) {
  try {
    const mintPubkey = new PublicKey(mintAddress);
    const largestAccounts = await connection.getTokenLargestAccounts(mintPubkey);
    
    const holders = [];
    let totalSupply = 0;
    
    for (const account of largestAccounts.value || []) {
      try {
        const accountInfo = await connection.getParsedAccountInfo(account.address);
        if (!accountInfo.value) continue;
        
        const info = accountInfo.value.data.parsed?.info;
        if (!info) continue;
        
        const amount = parseFloat(info.tokenAmount?.uiAmountString || "0");
        const isBurn = BURN_ADDRESSES.includes(info.owner);
        
        if (!isBurn && amount > 0) {
          holders.push({
            address: info.owner,
            amount: amount,
            pct: 0,
          });
        }
        
        totalSupply += amount;
      } catch {
        // Skip
      }
    }
    
    if (totalSupply > 0) {
      holders.forEach(h => {
        h.pct = (h.amount / totalSupply) * 100;
      });
    }
    
    holders.sort((a, b) => b.amount - a.amount);
    
    return {
      totalHolders: holders.length,
      topHolders: holders.slice(0, 10),
      totalSupply: totalSupply,
    };
  } catch (err) {
    return { totalHolders: 0, topHolders: [], totalSupply: 0 };
  }
}

async function checkLPBurnStatus(connection, lpMintAddress) {
  const result = {
    totalSupply: 0,
    burnedAmount: 0,
    burnPercentage: 0,
    mintAuthorityRevoked: false,
    topHolders: [],
  };

  if (!lpMintAddress) return result;

  try {
    const lpMintPubkey = new PublicKey(lpMintAddress);

    const mintInfo = await connection.getAccountInfo(lpMintPubkey);
    if (!mintInfo) return result;

    const data = mintInfo.data;
    if (data.length >= 82) {
      const supplyLow = BigInt(data.readUInt32LE(36));
      const supplyHigh = BigInt(data.readUInt32LE(40));
      result.totalSupply = Number((supplyHigh << BigInt(32)) | supplyLow);

      const mintAuthOption = data.readUInt32LE(0);
      result.mintAuthorityRevoked = mintAuthOption !== 1;
    }

    const largestAccounts = await connection.getTokenLargestAccounts(lpMintPubkey);

    for (const account of largestAccounts.value || []) {
      try {
        const accountInfo = await connection.getParsedAccountInfo(account.address);
        if (!accountInfo.value) continue;

        const info = accountInfo.value.data.parsed?.info;
        if (!info) continue;

        const amount = parseFloat(info.tokenAmount?.uiAmountString || "0");
        const isBurn = BURN_ADDRESSES.includes(info.owner);

        result.topHolders.push({
          address: info.owner,
          amount: amount,
          isBurnAddress: isBurn,
        });

        if (isBurn) {
          result.burnedAmount += amount;
        }
      } catch {
        // Skip
      }
    }

    if (result.totalSupply > 0) {
      result.burnPercentage = (result.burnedAmount / (result.totalSupply / Math.pow(10, 0))) * 100;
    }

    result.topHolders.sort((a, b) => b.amount - a.amount);
  } catch (err) {
    console.error(`Error checking LP burn: ${err.message}`);
  }

  return result;
}

async function checkBurnCheckedTxs(connection, lpMintAddress, limit = 100) {
  const burns = [];
  if (!lpMintAddress) return burns;

  try {
    const lpMintPubkey = new PublicKey(lpMintAddress);
    const signatures = await connection.getSignaturesForAddress(lpMintPubkey, { limit });

    for (const sigInfo of signatures) {
      try {
        const tx = await connection.getParsedTransaction(sigInfo.signature, {
          commitment: "confirmed",
          maxSupportedTransactionVersion: 0,
        });
        if (!tx || !tx.transaction?.message?.instructions) continue;

        for (const ix of tx.transaction.message.instructions) {
          if (!ix.parsed) continue;

          if (ix.parsed.type === "burnChecked" || ix.parsed.type === "burn") {
            const info = ix.parsed.info;
            const decimals = info.tokenAmount?.decimals || 9;
            const amount =
              info.tokenAmount?.uiAmount ||
              parseFloat(info.amount || 0) / Math.pow(10, decimals);

            burns.push({
              signature: sigInfo.signature,
              date: sigInfo.blockTime
                ? new Date(sigInfo.blockTime * 1000).toISOString()
                : "Unknown",
              type: ix.parsed.type,
              amount: amount,
              authority: info.authority || "Unknown",
              mint: info.mint || lpMintAddress,
            });
          }
        }
      } catch {
        // Skip
      }
    }
  } catch (err) {
    console.error(`Error checking burn txs: ${err.message}`);
  }

  return burns;
}

// â”€â”€â”€ Risk Scoring â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

function calculateRiskScore(tokenInfo, burnStatus, holderData, poolsCount) {
  let score = 0;
  
  // Mint authority (30 points if active)
  if (!tokenInfo.mintAuthorityRevoked) {
    score += 30;
  }
  
  // Freeze authority (20 points if active)
  if (!tokenInfo.freezeAuthorityRevoked) {
    score += 20;
  }
  
  // LP not burned (25 points max)
  if (burnStatus.totalSupply > 0) {
    const lpBurnedPct = burnStatus.burnPercentage;
    if (lpBurnedPct < 10) score += 25;
    else if (lpBurnedPct < 25) score += 15;
    else if (lpBurnedPct < 50) score += 5;
  }
  
  // Holder concentration (10-20 points)
  if (holderData.topHolders.length > 0) {
    const topHoldersPct = holderData.topHolders.slice(0, 5).reduce((sum, h) => sum + h.pct, 0);
    if (topHoldersPct > 50) score += 20;
    else if (topHoldersPct > 30) score += 10;
  }
  
  return Math.min(score, 100);
}

function getRiskRating(score) {
  if (score === 0) return { rating: "LOW ðŸŸ¢", color: "ðŸŸ¢" };
  if (score <= 25) return { rating: "LOW ðŸŸ¢", color: "ðŸŸ¢" };
  if (score <= 50) return { rating: "MEDIUM ðŸŸ¡", color: "ðŸŸ¡" };
  if (score <= 75) return { rating: "HIGH ðŸŸ ", color: "ðŸŸ " };
  return { rating: "CRITICAL ðŸ”´", color: "ðŸ”´" };
}

// â”€â”€â”€ Main â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

async function main() {
  const tokenAddress = process.argv[2];

  if (!tokenAddress) {
    console.error("Usage: node check-xdex-lp-burn.js <TOKEN_MINT_ADDRESS>");
    process.exit(1);
  }

  // Banner
  console.log();
  console.log("  â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—");
  console.log("  â•‘                                                        â•‘");
  console.log("  â•‘   ðŸ¦ž  X1 TOKEN AUDIT ENGINE  v2.5                      â•‘");
  console.log("  â•‘   â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”                            â•‘");
  console.log("  â•‘   XDEX Pool Analysis â€¢ BurnChecked Detection            â•‘");
  console.log("  â•‘   Powered by Loko_AI                                    â•‘");
  console.log("  â•‘                                                        â•‘");
  console.log("  â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•");
  console.log();
  console.log(`  ðŸ• ${timestamp()}`);
  console.log(`  ðŸ”— ${shortAddr(tokenAddress, 10)}`);
  console.log(`  ðŸŒ ${DEFAULT_RPC}`);

  // Fetch pools first for price calculation
  let pools = [];
  try {
    const response = await fetchJSON(`${XDEX_API}/xendex/pool/list`);
    const allPools = response.data || [];
    pools = allPools.filter(p =>
      p.token1_address === tokenAddress || p.token2_address === tokenAddress
    );
  } catch (err) {
    console.error(`  âŒ Error fetching pools: ${err.message}`);
    process.exit(1);
  }

  const connection = new Connection(DEFAULT_RPC, "confirmed");
  const mintPubkey = new PublicKey(tokenAddress);

  // â”€â”€â”€ TOKEN METADATA â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  console.log();
  console.log("  â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€");
  console.log("  ðŸ’° TOKEN METADATA");
  console.log("  â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€");
  const tokenData = await getTokenMetadata(tokenAddress, pools);
  console.log(`  Price:        ${tokenData.price}`);
  console.log(`  Market Cap:   ${tokenData.marketCap}`);
  console.log(`  Liquidity:    ${tokenData.liquidity}`);
  console.log(`  Vol 24h:      ${tokenData.volume24h}`);

  // â”€â”€â”€ TOKEN AUTHORITY CHECK â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  console.log();
  console.log("  â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€");
  console.log("  ðŸ” TOKEN AUTHORITY CHECK");
  console.log("  â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€");

  const tokenInfo = await checkTokenAuthorities(connection, mintPubkey);

  // â”€â”€â”€ TOKEN HOLDERS â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  console.log();
  console.log("  â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€");
  console.log("  ðŸ‘¥ TOKEN HOLDERS");
  console.log("  â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€");
  const holdersData = await getTokenHolders(connection, tokenAddress);
  console.log(`  Total Holders: ${holdersData.totalHolders}`);
  if (holdersData.topHolders.length > 0) {
    console.log("  Top Holders:");
    holdersData.topHolders.forEach((h, i) => {
      console.log(`    ${i + 1}. ${shortAddr(h.address)} - ${formatNumber(h.amount)} (${h.pct.toFixed(2)}%)`);
    });
  }

  // â”€â”€â”€ SUMMARY TABLE â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  console.log();
  console.log("  â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€");
  console.log("  ðŸ“Š AUDIT SUMMARY");
  console.log("  â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€");

  // Get burn status
  const lpBurnStatus = await checkLPBurnStatus(connection, tokenAddress);
  const riskScore = calculateRiskScore(tokenInfo, lpBurnStatus, holdersData, pools.length);
  const riskRating = getRiskRating(riskScore);

  // Count BurnChecked transactions - search by token mint, then filter by LP mints
  const burnCheckedTxs = [];
  const lpMints = pools.map(p => p.pool_info?.lpMint).filter(Boolean);
  const allSignatures = await connection.getSignaturesForAddress(mintPubkey, { limit: 100 });
  
  for (const sigInfo of allSignatures) {
    try {
      const tx = await connection.getParsedTransaction(sigInfo.signature, {
        commitment: "confirmed",
        maxSupportedTransactionVersion: 0,
      });
      if (!tx || !tx.transaction?.message?.instructions) continue;

      for (const ix of tx.transaction.message.instructions) {
        if (!ix.parsed) continue;

        if (ix.parsed.type === "burnChecked" || ix.parsed.type === "burn") {
          const info = ix.parsed.info;
          const decimals = info.tokenAmount?.decimals || 9;
          const amount =
            info.tokenAmount?.uiAmount ||
            parseFloat(info.amount || 0) / Math.pow(10, decimals);

          // Only count if LP mint matches our pools
          if (lpMints.includes(info.mint)) {
            burnCheckedTxs.push({
              signature: sigInfo.signature,
              date: sigInfo.blockTime
                ? new Date(sigInfo.blockTime * 1000).toISOString()
                : "Unknown",
              type: ix.parsed.type,
              amount: amount,
              authority: info.authority || "Unknown",
              mint: info.mint,
            });
          }
        }
      }
    } catch {
      // Skip
    }
  }

  // Calculate total burn from BurnChecked
  const totalBurnChecked = burnCheckedTxs.reduce((sum, tx) => sum + tx.amount, 0);
  const burnCheckedDate = burnCheckedTxs.length > 0 ? burnCheckedTxs[0].date.split('T')[0] : "N/A";

  // Burned via burn addresses
  const burnedBurnAddr = lpBurnStatus.burnedAmount;

  // LP Safety percentage
  const lpSafety = ((totalBurnChecked + burnedBurnAddr) / (holdersData.totalSupply || 1)) * 100;

  console.log("  | Metric                              | Value");
  console.log("  | ----------------------------------- | ------------");
  const mintAuthDisplay = tokenInfo.mintAuthorityRevoked ? "âœ… REVOKED" : `ðŸš« ACTIVE (${shortAddr(tokenInfo.mintAuthority)})`;
  const freezeAuthDisplay = tokenInfo.freezeAuthorityRevoked ? "âœ… REVOKED" : `ðŸš« ACTIVE (${shortAddr(tokenInfo.freezeAuthority)})`;
  console.log(`  | Mint Authority                      | ${mintAuthDisplay}`);
  console.log(`  | Freeze Authority                    | ${freezeAuthDisplay}`);
  console.log(`  | Total Supply                        | ${formatNumber(holdersData.totalSupply)} (${tokenInfo.decimals} decimals)`);
  console.log(`  | Pools Found                         | ${pools.length}`);
  console.log(`  | LP Burned (BurnChecked)            | ${formatNumber(totalBurnChecked)} (${burnCheckedTxs.length} txs)`);
  console.log(`  | LP Burned (Burn Addr)              | ${formatNumber(burnedBurnAddr)}`);
  console.log(`  | LP Safety                           | ${lpSafety.toFixed(1)}%`);
  console.log(`  | Risk Score                          | ${riskScore}/100 ${riskRating.color} ${riskRating.rating}`);

  // â”€â”€â”€ BURN CHECKED TRANSACTIONS â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  if (burnCheckedTxs.length > 0) {
    console.log();
    console.log("  â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€");
    console.log("  ðŸ”¥ BURNCHECKED TRANSACTIONS");
    console.log("  â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€");
    
    burnCheckedTxs.slice(0, 5).forEach((burn, i) => {
      const date = burn.date.split('T')[0];
      const txUrl = `https://explorer.mainnet.x1.xyz/tx/${burn.signature}`;
      console.log(`  ${i + 1}. ${formatNumber(burn.amount)} LP on ${date} ([TX Explorer](${txUrl}))`);
    });
  }

  // â”€â”€â”€ POOLS â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  console.log();
  console.log("  â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€");
  console.log("  ðŸŠ XDEX POOL DISCOVERY");
  console.log("  â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€");

  if (pools.length === 0) {
    console.log("  âŒ No pools found on XDEX\n");
  } else {
    console.log(`  âœ… Discovered ${pools.length} pool(s)\n`);
    
    pools.forEach((pool, i) => {
      const name = `${pool.token1_symbol}/${pool.token2_symbol} Pool`;
      // Parse hex lpSupply to decimal
      let supply = 0;
      try {
        if (pool.pool_info?.lpSupply) {
          supply = parseInt(pool.pool_info.lpSupply, 16) / 1e9;
        } else if (pool.total_supply) {
          supply = pool.total_supply / 1e9;
        }
      } catch (e) { supply = 0; }
      
      const burnsInPool = burnCheckedTxs.filter(tx => 
        pools.some(p => p.lpMint === pool.lpMint)
      ).length;
      
      if (burnsInPool > 0) {
        console.log(`  â€¢ ${name}: ${formatNumber(supply)} LP supply, ${burnsInPool} BurnChecked txs âœ…`);
      } else {
        console.log(`  â€¢ ${name}: ${formatNumber(supply)} LP supply`);
      }
    });
  }

  // â”€â”€â”€ SUMMARY â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  console.log();
  console.log("  â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€");
  console.log("  âœ… SUMMARY");
  console.log("  â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€");
  
  if (riskScore === 0) {
    console.log("  Strong security profile - mint/freeze revoked, LP");
    console.log(`  burn percentage: ${lpSafety.toFixed(1)}%.`);
    console.log("  ðŸŸ¢ LOW RISK.");
  } else {
    console.log(`  Risk factors detected: ${riskRating.rating}`);
    console.log("  Review authorities and LP burn status below.");
  }

  // Footer
  console.log();
  console.log(`  ðŸ”— Explorer: https://explorer.mainnet.x1.xyz/address/${tokenAddress}`);

  console.log();
  console.log("  â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”");
  console.log("  ðŸ¦ž Powered by Loko_AI Ã— X1 Token Audit Engine v2.5");
  console.log(`  ðŸ• ${timestamp()}`);
  console.log("  â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”");
  console.log();
}

main().catch(err => {
  console.error("Fatal error:", err);
  process.exit(1);
});
